\documentclass[a4paper,12pt,twoside]{article}

\usepackage[MeX]{polski}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{color}
\usepackage{url}
\usepackage{tocbibind}
\usepackage[]{units}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{longtable}
\usepackage{bbm}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{tabu}
\usepackage{tikz}
\usepackage[htt]{hyphenat}
\usepackage{todonotes}
%\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{mathtools}
\usepackage{cite}
\linespread{1.2}

% marginesy, szerokość i wysokość tekstu-
\setlength\topmargin{-0.25in}
\setlength\textheight{9in}
\setlength\headsep{0.2in}
\setlength\footskip{0.5in}
\setlength\oddsidemargin{0.4in}
\setlength\evensidemargin{0in}
\setlength\textwidth{5.8in}
\setlength\headheight{15.3pt}
\setlength\fboxsep{0pt}

% definicje nagłówków
%\usepackage{fancyhdr}
\pagestyle{plain}
%\renewcommand{\chaptermark}[1]{
%	\markboth{\MakeUppercase{
%			\chaptername\ \thechapter.
%			\ #1}}{}}
\newcommand{\Z}{\mathbbm{Z}}
\newcommand{\e}{\varepsilon}
\newcommand{\diam}{\operatorname{diam}}
%\fancypagestyle{plain}{ % styl: tylko numery stron
%	\fancyhf{}
%	\fancyfoot[C]{\thepage} % stopka: numer strony pośrodku
%	\renewcommand{\headrulewidth}{0pt}
%	\renewcommand{\footrulewidth}{0pt}}

%\fancypagestyle{headings}{% styl: numery stron i nagłówki
%	\fancyhf{}
%	\fancyhead[RO,LE]{\leftmark} % nagłówek prawo na nieparzystych, lewo na parzystych:
	% nazwa rozdziału
%	\fancyfoot[C]{\thepage} % stopka: numer strony pośrodku
%	\renewcommand{\headrulewidth}{0.3pt}
%	\renewcommand{\footrulewidth}{0pt}}
\newcommand{\N}{\mathbbm{N}}
\newcommand{\Q}{\mathbbm{Q}}
\newcommand{\R}{\mathbbm{R}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\card}{\operatorname{card}}
\usepackage{etoolbox}
\newcommand{\dd}{\delta}
\makeatletter
%\patchcmd{\epigraph}{\@epitext{#1}}{\itshape\@epitext{#1}}{}{}
\makeatother
\newcommand{\U}{\mathcal{U}}
% Zawartość
\newcommand{\B}{\mathcal{B}}
\theoremstyle{plain}
	\newtheorem{tw}{Twiedzenie}
	\newtheorem{lem}{Lemat}
\theoremstyle{definition}
	\newtheorem{defi}{Definicja}
	\newtheorem{ex}{Przykład}
\theoremstyle{remark}
	\newtheorem{obs}{Obserwacja}
	\newtheorem{remark}{Uwaga}
	\newtheorem{wniosek}{Wniosek}
	\newcommand\smallc{
		\mathchoice
		{{\scriptstyle\mathcal{C}}}% \displaystyle
		{{\scriptstyle\mathcal{C}}}% \textstyle
		{{\scriptscriptstyle\mathcal{C}}}% \scriptstyle
		{\scalebox{.7}{$\scriptscriptstyle\mathcal{C}$}}%\scriptscriptstyle
	}
\begin{document}
\begin{titlepage}
	\begin{flushleft}
	\end{flushleft}
	\begin{center}
		\textsc{{\huge Politechnika \L\'odzka}}
	\end{center}
	\bigskip
	\bigskip
	\begin{center}
		\textsc{{\Large Wydzia\l\ Fizyki Technicznej, Informatyki i~Matematyki Stosowanej}}
	\end{center}
	\bigskip
	\bigskip
	%\begin{center}
	\begin{Large}
		Kierunek: Informatyka\\   
		Przedmiot: Systemy wbudowane %TU WPISZ SPECJALNOŚĆ% 
	\end{Large}
	%\end{center}
	\bigskip
	\bigskip
	\bigskip
	\bigskip
	\begin{center}
		\textsc{\textbf{{\Large Dokumentacja gry zręcznościowej Procesja$^{\textrm{TM}}$ %TU WPISZ TYTUŁ PRACY%
					\\
					LPC1343 + Expansion Board
					}}}
	\end{center}
	\bigskip
	\bigskip
	\begin{flushright}
		{\large 
			\textbf{lider: mgr Filip Turoboś} %TU WPISZ SWOJE IMIĘ I NAZWISKO%
			\\
		\textbf{	Nr albumu: 
			210344 / 801147} %TU WPISZ SWÓJ NUMER ALBUMU%
			\\
			Jan Filipowicz %TU WPISZ SWOJE IMIĘ I NAZWISKO%
			\\
			Nr albumu: 
			203875 %TU WPISZ SWÓJ NUMER ALBUMU%
			\\
			Krzysztof Wierzbicki %TU WPISZ SWOJE IMIĘ I NAZWISKO%
			\\
			Nr albumu: 
			210347 %TU WPISZ SWÓJ NUMER ALBUMU%
			\\
		}
	\end{flushright}
	\noindent\hrulefill
		\begin{center}
		{\textsc{\large \L\'od\'z, \date{Listopad 2017} %TU WPISZ  MIESIĄC I ROK ODDANIA PRACY%
			}}
		\end{center}
	\end{titlepage}	
% !TeX spellcheck = pl_PL
%\begin{titlepage}
%
%\begin{minipage}{0.19\textwidth}
%\begin{flushleft}
%\includegraphics[width=0.88\textwidth]{img/logo}
%\end{flushleft}
%\end{minipage}
%\begin{minipage}[t][][t]{0.81\textwidth}
%\begin{flushleft}
%\vspace{-2\baselineskip}
%\textbf{{\large Politechnika Łódzka}\\}
%\vspace{\medskipamount}
%\textbf{\large Wydział Fizyki Technicznej, Informatyki\\i~Matematyki Stosowanej}
%\vspace{\medskipamount}\\ %oo
%{\large Instytut Matematyki}\\
%\end{flushleft}
%\end{minipage}
%\vspace{2.5cm}
%
%\begin{center}
%{\Large {Filip Turoboś, 206799\\}}
%\vspace{2cm}
%{\huge{ {Przestrzenie wyposażone\\ w funkcje typu odległości}}}
%\end{center}
%\vspace{3cm}
%\hfill
%\begin{minipage}{.65\columnwidth}
%Praca {magisterska}\\
%Promotor: prof. dr hab. inż. Jacek Jachymski
%\end{minipage}
%\vfill
%\begin{center}
%Łódź {2017}
%\end{center}
%\end{titlepage}
\tableofcontents
\newpage
\section{Podsumowanie i technikalia}
\subsection{Skład zespołu}
$\begin{array}{|l|l|l|}
	\hline
	\textrm{Funkcja:}& \textrm{Imię i nazwisko: }& \textrm{Nr albumu: }\\
	\hline
	\textrm{lider}& \textrm{Filip Turoboś}&\textrm{ 210344, 801147}\\
	\hline
	\textrm{członek}&\textrm{Jan Filipowicz}&\textrm{	203875 	}\\
	\hline
	\textrm{członek}&\textrm{Krzysztof Wierzbicki}& \textrm{210347}\\
	\hline
\end{array}$
	% do poprawy
\subsection{Sprzęt}
Na potrzeby projektu nie wykonywano żadnego własnego sprzętu.
Do projektu wykorzystano LPC1343 i Expansion Board.
\subsection{Wykorzystane funkcjonalności i ich autorzy}
%\subsubsection{MCU}

%\subsubsection{Urządzenia peryferyjne}
\begin{tabular}{|c|c|} \hline
	 Timer&{Krzysztof Wierzbicki}\\ \hline
	 GPIO&{Jan Filipowicz}\\ \hline
	 ADC&{Turoboś Filip}\\ \hline
	 SPI/SSP&{Krzysztof Wierzbicki}\\ \hline
	 I$^2$C&{Jan Filipowicz}\\ \hline
	 Wyświetlacz siedmiosegmentowy&{Turoboś Filip}\\ \hline
	 Wyświetlacz LCD&{Krzysztof Wierzbicki}\\ \hline
	 Przerwania&{Jan Filipowicz}\\ \hline
	 Melodia&{Krzysztof Wierzbicki}\\ \hline
	 Akcelerometr&{Turoboś Filip}\\ \hline
	 Czujnik światła&{Turoboś Filip}\\ \hline
	 Diody LED -- Ekspander (PCA 9532)&{Krzysztof Wierzbicki}\\ \hline
\end{tabular}
\subsubsection{Dokumentacja, analiza FMEA i inne uwagi}
Algorytm Gry: Jan Filipowicz;

\noindent Analiza FMEA: Cały zespół;

\noindent Skład i opracowanie całości dokumentu: Filip Turoboś;

W naszym odczuciu praca w zespole została rozłożona stosunkowo równomiernie. Nad niemal każdą z funkcjonalności (a także opisem w dokumentacji) pracowaliśmy całym zespołem.

\subsubsection{Procentowy udział poszczególnych członków zespołu w tworzeniu końcowej wersji projektu}
$\begin{array}{|l|l|l|}
\hline
\textrm{Imię i nazwisko: }& \textrm{Procentowy udział: }\\
\hline
 \textrm{Filip Turoboś}&\textrm{ 33\%}\\
\hline
\textrm{Jan Filipowicz}&\textrm{	33\% 	}\\
\hline
\textrm{Krzysztof Wierzbicki}& \textrm{34\%}\\
\hline
\end{array}$
\newpage
\section{Skrótowy opis działania programu}
Podczas gry w Procesja$^{\textrm{TM}}$ gracz manewruje przy pomocy joysticka i/lub akcelerometru białą łamaną symbolizującą procesję i stara się poruszać nią w taki sposób, aby:
\begin{itemize}
	\item nie przecinać tworzonej przez siebie łamanej; 
	\item zbierać pojawiające się na planszy kropki symbolizujące zbłąkane owieczki.
\end{itemize}

W przypadku gdy gracz najedzie łamaną na pulsującą kropkę, całość procesji zostaje przedłużona. Radując się z ilości zgromadzonych wiernych możemy odgrywać pieśń religijną \textit{"Barka"}.

\section{Algorytm gry}
Gra działa na zasadzie popularnej gry Snake -- procesja porusza poprzez usunięcie ostatniej kropki (ostatniego segmentu symbolizującego wiernego) i dodaniu kropki symbolizującej proboszcza na początku procesji. Rozpoczęcie gry polega na zainicjalizowaniu pięciu kropek tworzących procesję na środku poziomu (poziom ma wymiary $32 \times 21$ punktów) oraz utworzeniu kropki wiernego w losowym miejscu na planszy.

Procesja porusza się ruchem jednostajnym w ostatnim wskazanym przez gracza kierunku (początkowo w górę). Pochód może przechodzić przez \textit{ścianki} poziomu, kontynuuje on wówczas swój ruch po przeciwnej stronie ekranu (poziom jest \textit{de facto} homeomorficzny z torusem). Przy każdym ruchu procesji obliczana jest odległość proboszcza (początku procesji) od zbłąkanej owieczki, która mruga. Gdy odległość ta wynosi nie więcej niż \verb|TOLERANCE| (zmienna oznaczająca precyzję wymaganą od gracza, domyślnie ma wartość zero) wierny dołącza do pochodu, wydłużając długość procesji o jeden. Fakt ten sygnalizowany jest błyśnięciem diodami LED. Ponadto w losowym miejscu pojawia się nowa zbłądana owieczka. Jeżeli czoło pochodu zderzy się z jego częścią (lub zostanie zakryty czujnik światła) to gra się restartuje, wracając do stanu początkowego. 
\section{Funkcjonalności}
\subsection{Timer}
Układ, który dekrementuje lub inkrementuje wartość jednego ze swoich rejestrów w zależności od częstotliwości otrzymywanego sygnału nazywamy \textbf{timerem}. Każdy timer jest wyposażony w dwa podstawowe rejestry -- licznik timera i rejestr kontroli timera. W przypadku płytki LPC 1343 timer jest dodatkowo wyposażony w preskaler. Zwiększenie licznika timera $(TC)$ -- \textit{timer counter} następuje po spełnieniu następujących warunków:
\begin{itemize}
\item Wartość rejestru preskalera $(PR)$ jest ustawiona na pewną wartość $K\in \N_0$ -- domyślnie $K=0$;
\item 32-bitowy licznik preskalera $(PC)$ osiągnie wartość $K+1$;
\end{itemize}
Po inkrementacji $(TC)$ następuje wyzerowanie licznika preskalera.

Aby uruchomić timer należy:
\begin{itemize}
	\item Uruchomić przesyłanie sygnału zegarowego do 32-bitowego timera o numerze zero (CT32B0) \cite{INST}: 
	\begin{verbatim}
	LPC_SYSCON->SYSAHBCLKCTRL |= (1<<9);
	\end{verbatim}
	\item Wybrać pin 5 z portu 1 do odbierania sygnału z wejścia input 0 CT32B0 ;
	\item Ustawiamy wejście sygnału z match registrów 0 - 2 porty 1.6, 1.7, 0.1 ;
	\item W match registrze timera ustawiamy interwał tj. odległość między kolejnymi dopasowaniami;
	\item W match control registrze TMR32B0MCR ustawiamy \verb|0b11| - wyślij przerwanie i zresetuj jeżeli MR0 (zgodnie ze stroną 287 \cite{INST});
	\item Włączamy przerwania rejestrem ISER (Interrupt Set Enable Register):
\begin{verbatim}
NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));
\end{verbatim}
\end{itemize}

\subsection{GPIO}
Skrót $(GPIO)$ oznacza \textit{General purpose input/output}, czyli \textbf{interfejs wejścia /wyjścia ogólnego przeznaczenia}. Przy pomocy $(GPIO)$ obsługiwany jest joystick, w który wyposażona jest płytka. Służy on do poruszania się instancją obiektu typu wąż, umożliwiając tym samym granie w grę.

Aby używać joysticka musimy najpierw ustalić rolę odpowiednich pinów na \textit{INPUT}. W naszym przypadku stosowane jest port nr 2 i piny od $0$ do $4$, odpowiadających za poszczególne kierunki (odpowiednio centrum/dół/prawo/góra/lewo). 

Posuszanie procesją polega na sprawdzaniu stanów poszczególnych pinów. Przykładowo, gdy ostatnio odczytany stan wysoki wystąpił na pinie nr 2, nasz wąż zacznie poruszać się w prawo (o ile jest to możliwe, tj. nie poruszał się uprzednio w lewo). Jeżeli nie jest odczytywany obecnie stan wysoki na żadnym z pinów, to wąż kontynuuje poruszanie się w ostatnio wybranym kierunku. W przypadku, gdy odczytany ruch jest przeciwny do obecnego, sygnał odebrany z $(GPIO)$ zostanie zignorowany.



%Joystick czytamy z portu 2 piny 0..4

\subsection{PCA9532}
Diody przez ekspander nie wymagają inicjalizacji. 
Ich użycie sprowadza się do:
	\begin{itemize}
		\item Ustalenia, które diody mają zostać włączone;
		\item Przez I2C pod adres \verb|(0x60 << 1)| wysyłamy bajt kontrolny, którego 4 dolne bity oznaczają adres pierwszego rejestru, do którego chcemy zapisać informacje - \verb|0x06|. Piąty bit oznacza flagę inkrementacji, dzięki której podany przez nas adres jest zwiększany o 1 przy każdym kolejnym przesłanym bajcie. Istotne jest to, by trzy górne bity były zerami \cite{PCA};
		\item Pod ten sam adres przesłania 32 bitów informacji do ekspandera, gdzie na każdą diodę przypadają dwa bity informacji, określające stan, w którym ma się znaleźć. Możliwe są cztery stany \cite{PCA} -- ON, OFF, Blink 1 i Blink2 (korzystamy jedynie z pierwszych dwóch).
	\end{itemize}
W przypadku naszego programu diody LED zapalają się sześciokrotnie, gdy do procesji dołączy kolejny wierny (kolory pojawiają się naprzemiennie). 

\subsection{ADC}
\textit{Analog-Digital Converter}, czyli
\textbf{Konwerter analogowo-cyfrowy} $(ADC)$ jest przetwornikiem pozwalającym na zmianę zewnętrznego sygnału analogowego (w naszym przypadku napięcia) na ciąg $10$ bitów. $ADC$ na stosowanym przez nas mikrokontrolerze używa algorytmu sukcesywnej aproksymacji, którego krótki opis załączony zostanie w podrozdziale \textbf{Algorytm sukcesywnej aproksymacji w $ADC$}.

Przy pomocy $ADC$ gracz jest w stanie kontrolować prędkość poruszanej przez siebie procesji. Precyzyjnie, jeden krok procesji zajmuje
\[
\operatorname{new\_snek\_speed} =\left( \left\lfloor \frac{4000}{ \operatorname{ADCread}(0)} \right\rfloor + 20 \right) \; ms.
\]
Do odczytu wartości z ADC stosowana jest funkcja \textit{ADCread(0)}, która odczytuje wartość napięcia na zerowym pinie.
Odczytywane przez nas wartości z $ADC$ są liczbami całkowitymi z przedziału $[39;1023]$. Dzięki temu nigdy nie dochodzi do dzielenia przez zerową wartość. Funkcja odczytująca wartość wywoływana jest przy każdym obrocie głównej pętli programu. Dzięki temu wartość prędkość procesji jest dostosowywana na bieżąco do aktualnego napięcia na zerowym pinie $ADC$, które kontroluje użytkownik przy pomocy pokrętła A22K. Zgodnie z \cite{INST} napięcie to mieści się w zakresie od $0$ do $3.6 \;V$. 
Inicjalizacja konwertera analogowo-cyfrowego przebiega w następujący sposób:
\begin{enumerate}
	\item Zerujemy bit odpowiadający za odłączenie od zasilania bloku konwertera:
		\begin{verbatim}
		  LPC_SYSCON->PDRUNCFG &= ~(0x1<<4);
		\end{verbatim}
	\item Uruchamiamy zegar AHB dla bloku ADC
		\begin{verbatim}
		  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<13);
		\end{verbatim}
	\item Do rejestru \verb|IOCON_PIO1_4| na pierwszych dwóch bitach wpisywana jest wartość 0x01, odpowiadająca funkcji AD5, która zwraca przez input 5 \cite{INST} oraz do \verb|JTAG_TDI_PIO0_11| wpisujemy 0x02, co odpowiada inicjalizacji funkcji AD0, zwracającej przez input 0.
	
	\item Konfigurujemy rejestr kontrolny przetwornika następująco:
	\begin{verbatim}
	 LPC_ADC->CR = ( 0x01 << 0 ) |  
	 (((SystemCoreClock/LPC_SYSCON->SYSAHBCLKDIV)/ADC_Clk-1)<<8) |
	 ( 0 << 16 ) | 		
	 ( 0 << 17 ) |  		
	 ( 0 << 22 ) |  		
	 ( 0 << 24 ) |  		
	\end{verbatim}
	Poszczególne elementy konfiguracji opisane są poniżej
	\begin{itemize}
		\item \verb|0x01<<0| -- wybór zerowego pina (AD0) do konwersji;
		\item \verb|(((SystemCoreClock/LPC_SYSCON->SYSAHBCLKDIV)/ADC_Clk-1)<<8)| --  dzielnik zegara dla ADC;
		\item \verb|0<<16| -- wybór trybu kontroli oprogramowaniem (\textit{software controlled mode}), pozwalającej na wykorzystanie tylko jednego kanału (co zgadza się z naszą konfiguracją, bo jedynie pierwszy bit z pierwszego bajta tego rejestru ma wartość 1);
		\item \verb|0<<17| -- konwersja na 10 bitów/11 cykli zegarowych;
		\item \verb|0<<24| -- nie zaczynamy konwersji;
	\end{itemize}
\end{enumerate}
Na szczególną uwagę zasługuje ustawienie dzielnika zegara dla ADC. Ponieważ w naszym przypadku wartość zmiennej ADC\_Clk wynosi $1$ MHz, to dzielnik zegara ADC wynosić będzie (współczynnik bez jednostki):
\[
CLKDIV = ( 60 000 000 \textrm{ Hz }/ 1 ) / 1000000\textrm{ Hz } - 1 = 59;
\]

Aby odczytać wskazanie z ADC stosujemy funkcję ADCread(0) wybieramy (w naszym wypadku) kanał zerowy i rozpoczynamy konwersję, przestawiając wartość 24 bitu rejestru kontrolnego ADC na 1, co oznacza natychmiastowe rozpoczęcie konwersji.
\begin{verbatim}
LPC_ADC->CR |= (1 << 24) | (1 << 0);
\end{verbatim}
Wynik konwersji zapisywany jest do rejestru o adresie \verb|0x4001 C010| (na bitach od 6 do 15 włącznie), a następnie do zmiennej regVal. Fakt, że odczyt się powiódł oznacza że ostatni bit ma wartość 1 (zostaje on ustawiony przy zakończeniu konwersji i wyzerowany po odczytaniu). Przy korzystaniu z trybu sprzętowego BURST, należy dodatkowo sprawdzić, czy któreś konwersje nie zostały utracone (mówi nam o tym wartość 1 na przedostatnim bicie).

Ostateczny wynik odczytu, który zwracany jest przez funkcję ADCRead(0)  ma postać:
\begin{verbatim}
ADC_Data = ( regVal >> 6 ) & 0x3FF;
\end{verbatim}
przesuwamy na początek zmiennej wynik konwersji i zerujemy bity o numerach większych niż 10 (bo tyle bitów zajmuje wynik konwersji).

	\subsubsection{Algorytm sukcesywnej aproksymacji $ADC$ \cite{ADCINST}}
	Algorytm sukcesywnej aproksymacji jest w istocie sprzętową wersją przeszukiwania binarnego. Rejestr SAR (\textit{Successive Approximation Register}), do którego zapisywana bedzie odczytana z konwertera wartość jest pierwotnie zainicjalizowany samymi zerami, zaś najbardziej znaczący bit jest przestawiany na wartość $1$. Następnie wartość rejestru jest konwertowana na sygnał analogowy, po czym komparator porównuje napięcie wejściowe z konwertera z napięciem odpowiadającym ciągowi bitów z rejestru SAR. Jeżeli napięcie wejściowe w konwerterze (czyli sygnał otrzymywany dzięki ustawieniu pokrętła na odpowiedniej pozycji) przekracza wartość napięcia wygenerowanego na podstawie rejestru -- bit wiodący pozostaje w stanie $1$, w przeciwnym razie przypisana zostaje mu wartość $0$. Następnie analogiczne postępowanie zostaje przeprowadzane dla sukcesywnego bitu. Procedura powtarzana jest dziesięciokrotnie, do zapełnienia całego rejestru.

\subsection{SSP/SPI}
\textit{Serial Peripheral Interface / Synchronous Serial Port}, szeregowy interfejs SSP jest używany, by komunikować się z wyświetlaczami. W tym przypadku używamy protokołu SPI. Komunikacja przebiega synchronicznie poprzez trzy równoległe linie. Są nimi
\begin{itemize}
	\item $MOSI$ - \textit{Master Input Slave Output} pozwala na wysyłanie danych do zewnętrznego układu (w naszym wypadku wyświetlaczy);
	\item $MISO$ - \textit{Master Output Slave Input} służy do pobierania danych z układu zewnętrznego;
	\item $SCLK$ - \textit{Serial CLocK} zegar taktujący -- precyzyjniej sygnał zegarowy.
	\item $SSEL$ - \textit{Slave SELect} służy do ustalenia które urządzenie jest slave.
\end{itemize} 
	Najpierw podłączamy zegar systemowy do SSP (przez szynę AHB) w następujący sposób \cite{INST}:
\begin{verbatim}
  LPC_SYSCON->PRESETCTRL |= (0x1<<0); // zaprzestań resetowania SSP
  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<11); // włącz zegar dla SSP
\end{verbatim}
	Dalej, ustawiana jest częstotliwość zegara przez jako odpowiednia część częstotliwości zegara peryferalnego:
\begin{verbatim}
  LPC_SYSCON->SSPCLKDIV = 0x02;	//dzielnik zegara peryferalnego
\end{verbatim}

Następnie w rejestrach kontroli wejścia/wyjścia ustawiamy linie MISO i MOSI na port 0, piny 8 i 9
\begin{verbatim}
  LPC_IOCON->PIO0_8   |= 0x01;	// MISO
  LPC_IOCON->PIO0_9   |= 0x01;	// MOSI
  \end{verbatim}
  Kolejnym krokiem jest ustawienie głównej płytki jako master -- 2 bit portu 0 GPIO jest wybierany jako wyjście i ustawiany jest na nim stan wysoki. 
  
Następnie ustawiamy linię SCKL - wartość 1 na porcie 2 pin 11.

Aby można było użyć zegara na tym pinie, należy także wybrać funkcję 1 przez rejestr lokacji SCK
\begin{verbatim}
LPC_IOCON->SCKLOC = 0x01;
\end{verbatim}

Następnie ustawiamy DSS (Data Size Select) na transmisję 8-bitową, format ramki na SPI, polarność zegara, jego fazowość, oraz SCR (Serial Clock Rate) na 15 -- ilość sygnałów z preskalera na bit na szynie
\begin{verbatim}
LPC_SSP->CR0 = 0x0707;
\end{verbatim}

Ustawiamy SSP preskaler
\begin{verbatim}
LPC_SSP->CPSR = 0x2;
\end{verbatim}

Ostatecznie częstotliwośc SPI to 30MHz.

Następnie w kontrolerze przerwań włączamy przerwania SSP.

Transmisja po SPI (dla każdego bajtu informacji) polega kolejno na: odczekaniu aż zniknie status "zajęty" (BSY) w rejestrze kontrolnym \verb|LPC_SSP->SR|,
a następnie przesłniu do rejestru danych \verb|LPC_SSP->DR| jednego bajtu z bufora. 


\subsection{I$^2$C}
NIE działa przez interfejs SSP.

\subsection{Wyświetlacz siedmiosegmentowy}
W zaprojektowanej grze wyświetlacz siedmiosegmentowy służy jako element dekoracyjny i nie ma wpływu na rozgrywkę. Przez cały czas trwania rozgrywki wyświetla on kolejne litery napisu.

1. Inicjalizacja wyświetlacza siedmiosegmentowego polega na ustawieniu kierunku w pierwszym porcie GPIO. Na 11 bicie ustawiana jest wartość 1, co oznacza kierunek wyjściowy
\begin{verbatim}
		LPC_GPIO1->DIR |= (0x1<<11);
\end{verbatim}
a następnie ustawienie na tym bicie wartości 1, przy czym tak zainicjalizowany wyświetlacz nie wyświetla jeszcze żadnego znaku.
\begin{verbatim}
 GPIOShadowPort1 |= (1<<11);
\end{verbatim}

2. Deklarujemy wartość zmiennej letters\_speed, która opisywać będzie co ile iteracji głównej pętli programu nastąpi zmiana wyświetlanego znaku (poprzedzona jednoiteracyjną przerwą):
\begin{verbatim}
const uint8_t letters_speed = 10;
\end{verbatim}
Tablica znaków do wyświetlania przez wyświetlacz siedmiosegmentowy ma następującą deklarację:
\begin{verbatim}
const uint8_t letters[] = "NO STEP ON SNECC ";
\end{verbatim}

3. W pojedynczej iteracji głównej pętli programu wykonujemy następujące kroki:

$\quad$ 3.1 Upewniamy się, że zmienna kontrolująca wartość wyświetlanej litery letters\_state nie przekroczy wartości \textbf{sizeof}(letters)$\cdot$letters\_speed.
\begin{verbatim}
letters_state %= letters_size * letters_speed;
\end{verbatim}

$\quad$ 3.2 Wybieramy instrukcją warunkową czy obecnie wyświetlany jest znak z tablicy letters, czy też następuje przerwa, która czyni napis czytelniejszym dla użytkownika. Zestaw stosowanych w programie znaków pozwala wyświetlić każdy z nich na wyświetlaczu siedmiosegmentowym. Zero przekazywane jako drugi argument funkcji sprawia, że nie wchodzimy w tryb surowego przesyłu danych (tryb w którym korzystamy z funkcji led7seg\_setChar sprawia, że litery odczytywane są jako znaki ASCII):
\begin{verbatim}
led7seg_setChar(letters_state % letters_speed ?
letters[letters_state / letters_speed] : ' ', FALSE);
\end{verbatim}
Funkcja ta przy pomocy metody SSPSend przekazuje stablicowane ośmiobitowe wartości całkowite odpowiadające poszczególnym wyświetlanym znakom. Przykładowo, wartością odpowiadającą literze '\textbf{S}' jest 0x12. Przed przesłaniem przez SSP jakichkolwiek danych musimy jednak zmienić wartość jedenastego bitu pierwszego portu GPIO na 0. 
\begin{verbatim}
GPIOShadowPort1 &= ~(1<<bitPosi);
\end{verbatim}
Po zakończeniu przesyłania zmiennej zostaje on ponownie przywrócony do stanu 1 tak samo jak przy inicjalizacji.

$\quad$ 3.3 Zwiększamy wartość letters\_state o jeden.
\begin{verbatim}
letters_state++;
\end{verbatim}
\subsection{Wyświetlacz LCD}

Komunikacja przebiega za pomocą interfejsu SPI, a przesyłane dane są 8-bitowe. 
Aby wysłać dane należy ustawić kontroler ekranu OLED jako slave (wartość 0 na lini SSEL(PORT0\_2).
Interpretacja przesyłanych zależy od sygnału ustawionego na 7 bicie portu 2. W przypadku gdy
jest on 1 przesyłane dane są interpretowane jako dane, w przeciwnym wypadku jako komendy. 


Wyświetlacz składa się z 8 stron (każda to fragment ekranu o pełnej szerokości i wysokości 8 pikseli), 
z których każda ma 136 bajtów (maksymalna szerokość ekranu obsługiwana przez kontroler), a każdy bajt opisuje 
osiem pikseli o kolejnych współrzędnych y.
Ustawienie koloru pojedynczego piksela polega na wysłaniu jako komenda adresu strony (\verb|0xB0|...\verb|0xB7|), 
następnie adresu bajtu \verb|0bABCDEFGH| w postaci kolejnych bajtów 
\verb|0b0000EFGH| i \verb|0b0001ABCD|. Następnie jako dane wysyłamy pod ustawiony adres maskę, gdzie wartość 1 oznacza biały piksel a wartość 0 czarny.

\subsection{Przerwania (Interrupts)}

\textbf{Przerwanie} to sygnał dla procesora pochodzący ze sprzętu bądź oprogramowania, informujący o zajściu zdarzenia wymagającego natychmiastowego przetworzenia. Procesor, otrzymawszy taki sygnał, zawiesza wykonywanie obecnego kodu, zachowuje swój stan, i przechodzi do przetwarzania przerwania. Nasz program wykorzystuje przerwania z zegara (\textit{timer}) w celu odtwarzania melodii niezależnie od algorytmu gry.

Korzystamy z $32$-bitowego timera $1$ (CT32B1) o preskalerze ustawionym na $1$ mikrosekundę. Podczas inicjalizacji timera opisanej szczegółowo osobno w poświęconej mu sekcji, w celu włączenia pochodzących zeń przerwań ustawiamy bit zerowy i pierwszy w rejestrze \textit{Match Control Register} TMR32B1 MCR (tj. wartość liczbową \verb|0b11|), co odpowiednio oznacza, że przerwania mają być generowane przy osiągnięciu wartości MR0, oraz że timer, przy osiągnięciu tej wartości, ma być resetowany do zera. Następnie włączamy w kontrolerze przerwań (NVIC, \textit{Nested Vectored Interrupt Controller}) obsługę przerwań z $32$-bitowego timera $1$ poprzez ustawienie odpowiadającego mu dwunastego bitu w rejestrze ISER1.

Przerwania użytego timera obsługuje funkcja \mbox{TIMER32\_1\_IRQHandler}, której adres jest przechowywany w zerowym bloku pamięci RAM wraz z innymi procedurami obsługi zdarzeń. Obsługa tego przerwania zaczyna się w naszym przypadku od ustawienia zerowego bitu rejestru TMR32B1 IR w celu zresetowania przerwania. W ogólnym przypadku należałoby odczytać ów rejestr, aby ustalić rodzaj zdarzenia, i następnie ustawić bit w zależności od tego rodzaju, jednak nasz program generuje tylko jeden rodzaj przerwań z timera, więc byłoby to zbędne. Potem następuje właściwa część obsługi służąca odegraniu melodii. Ta część ustawia również rejestr MR0 na ilość czasu daną w mikrosekundach, po której powinno zajść kolejne przerwanie, co zależy od częstotliwości obecnie granej nuty lub długości obecnej pauzy.

\subsection{Głośnik (GPIO) -- Melodia}
%Aby zainicjalizować głośniczek ustawiamy kierunek 
%\begin{verbatim}
%LPC_GPIO1->DATA |= (0x1<<2)
%\end{verbatim}
Odgrywanie melodii realizowane jest w handlerze przerwania 32 bitowego timera nr 1 i kontrolowane za pomocą zmiennej
\verb|is_play_song|. Jeżeli jej wartość logiczna odpowiada prawdzie, zaczyna się przetwarzanie. Melodia jest zapisana jako ciąg znaków, 
gdzie każde kolejne trzy oznaczają wysokość dźwięku (zakodowana jako litery a-g i A-G), długość jego trwania (zakodowana jako znak 0-9) i długość następującej 
po dźwięku pauzy (zakodowana jako jeden ze znaków [+.-\_]). Z ciągu odczytywana jest wysokość dźwięku, dekodowana jest jako wysokość dźwięku w hercach 
(między 262 a 988 Hz), długość dźwięku w milisekundach (między 0 a 1800 ms) oraz długość pauzy w milisekundach (między 0 a 30 ms).
Następnie rejestr \verb|MR0| jest ustawiany na połowę okresu dźwięku o danej częstotliwości w mikrosekundach \[ 1000000[\mu s/s]/(pitch[Hz] \cdot 2),\] 
licznik ustawiany jest ilość zmian sygnału w danym dźwięku \[(duration[ms] * 1000[\mu s/ms])/half\_period[ms].\] Następnie w związku z przestawieniem rejestru \verb|MR0| 
funkcja jest wywoływana co połowę okresu i za każdym razem nastepuje zmiana sygnału przekazywanego na głośnik -- w ten sposób odtwarzany jest dźwięk. 
Po zakończeniu odtwarzania dźwięku \verb|MR0| zostaje ustawiony na długość pauzy w milisekundach, a przy następnym wywołaniu (po zakończeniu trwania pauzy) 
rejestr \verb|MR0| zostaje ustawiony na 1000 [ms] i algorytm oczekuje na kolejny sygnał odtworzenia melodii.
\subsection{Akcelerometr}
\textbf{Akcelerometr} to urządzenie zdolne do wykrycia i pomiaru oddziałującego nań wektora przyspieszenia. W proponowanym przez nas programie służy on jako alternatywna dla joysticka metoda sterowania procesją. Gracz przechylając w odpowiednim kierunku mikrokomputer sprawia, że procesja skręca we wskazaną stronę.

Zastosowany w naszym układzie akcelerometr MMA7455L jest inicjowany przez zdefiniowanie trybu pomiaru i zakresu poprzez przypisanie (przy pomocy I$^2$C) do rejestru MCR (\textit{Mode Control Register} o adresie \verb|0x16|) wartości 1 na bit zerowy i drugi (przejście w \textit{Measurement Mode}, tj. tryb pomiarowy przy zakresie $2 \; g$, przekładający się na większą precyzję pomiaru \cite{ACCEL}).

Przy odczycie najpierw sprawdzamy rejestr statusu akcelerometru o adresie \verb|0x09|. Zerowy bit tego rejestru -- oznaczony przez DRDY -- informuje nas, czy dane są gotowe do odczytania. Jeżeli tak, to z rejestru o adresie \verb|0x06| pobierany jest  
odczyt $8$ bitów opisujących składową $X$ wektora przyspieszenia. Następnie odczytywane są wartości z rejestrów \verb|0x07| i \verb|0x08| odnoszące się odpowiednio do składowych $Y$ i $Z$. Warto zauważyć, że współrzędna $Z$ służy jedynie do autodiagnostyki urządzenia. Nie bierze ona udziału w sterowaniu procesją w sposób bezpośredni.

Następnie, jeżeli odczytane wartości na współrzędnych $X$ oraz $Y$ przekraczają (co do modułu) wartość $\frac{10}{64} \; g$, to ustawiane są odpowiednie (1/2 dla kierunków góra/dół, 3/4 dla kierunków prawo/lewo) bity zmiennej sterującej, która (po wykonaniu bitowej operacji OR ze zmienną przechowującą odczyt z joysticka) zostaje przekazana do funkcji odpowiadającej za przetwarzanie procesji.

\subsection{Czujnik \'Swiatła}
Czujnik światła przyłączony jest do płytki magistralą I$^2$C \cite{LUX}. Pod adres szyną I$^2$C \verb|(0x44 << 1)| przesyłane są wartości (kolejno) \{\verb|0x00|, \verb|(1 << 7)|\}. Powoduje to ustawienie wartości $1$ na siódmym bicie rejestru Command Register. Bit ten odpowiada za uruchomienie stosownego przetwornika analogowo-cyfrowego w czujniku.

Ustawiamy następnie wartości 0 i 1 na (odpowiednio) bitach o numerach 2 i 3. Sprawia to, że zakres odczytu czujnika zmieni się z domyślnych $1000$ luksów do $4000$ luksów.

Odczyt czujnika światła znajduje się w rejestrach LSB\_sensor (rejestr o adresie \verb|0x04|) -- odpowiadający za dolną połowę odczytu i MSB\_sensor (rejestr o adresie \verb|0x05|), w którym znajduje się bajt górnej połowy odczytu. Przekazywany jest on do programu przez I$^2$C, a konkretnie do zmiennej nazwanej \verb|data|. Ostateczny odczyt ma wartość
\begin{verbatim}
 3892 * data / (1 << 16)
\end{verbatim}
i wyrażony jest w luksach.

W programie czujnik światła został zastosowany do zrestartowania gry w momencie, gdy odczyty natężenia oświetlenia spadną poniżej $100$ luksów (np. w wyniku zakrycia czujnika światła palcem).

\section{Analiza FMEA}

\begin{center}
	\hspace*{-50pt}\begin{tabular}{|c|c|c|c|c|}\hline
		Możliwa awaria & Prawdopodobieństwo & Reakcja & Istotność & Iloczyn  \\ \hline\hline % <-- note that two \hlines produce a double line
		Uszkodzenie wyświetlacza LCD & Niewielkie $0.05$ & Nie & Krytyczna $10$ & $0.5$ \\ \hline
		Uszkodzenie czujnika światła & Małe $0.08$ & Nie & Krytyczna $10$ & $0.8$ \\ \hline
	\color{red}	Uszkodzenie joysticka &\color{red} \'Srednie $0.2$ &\color{red} Tak &\color{red} Wysoka $8$ &\color{red} $1.6$ \\ \hline
	\color{red}	Uszkodzenie akcelerometru &\color{red} \'Srednie $0.3$ &\color{red} Tak &\color{red} \'Srednia $6$ &\color{red} $1.8$ \\ \hline
	\color{black}Uszkodzenie wyświetlacza 7segmentowego & Znikome $0.01$ & Nie & Zerowa $0.1$ & $0.001$ \\ \hline
	\color{black}Uszkodzenie pokrętła ADC & Małe $0.15$ & Nie & Mała $2$ & $0.3$ \\ \hline
	\end{tabular}
\end{center}
	\subsection{Uszkodzenie wyświetlacza LCD}
	Możliwe uszkodzenie wyświetlacza LCD spowoduje całkowitą niegrywalność. Nawet jeżeli możliwa byłaby autodiagnostyka tego przypadku, uznano że urządzenie miałoby nikłe szanse na sensowną reakcję na wypadek tego typu awarii.
	
	\subsection{Uszkodzenie czujnika światła}
	Uszkodzenie czujnika światła może generować problemy dwojakiego rodzaju, z których tylko jeden ma dla nas istotne znaczenie. W przypadku gdy odczytywane wartości są zbyt wysokie (tj. czujnik nie wykrywa zmniejszenia intensywności oświetlenia) problem nie jest krytyczny dla działania układu -- niemożliwe staje się wówczas jedynie zrestartowanie gry. Uszkodzenie czujnika, które sprawi, że odczytywane wartości natężenia światła będą poniżej $100$ luksów uczyni Procesję całkowicie niegrywalną, z powodu nieprzerwanego restartowania gry. Niestety w tej sytuacji nie zostały podjęte żadne działania naprawcze.
		
	\subsection{Uszkodzenie akcelerometru}
	Uszkodzenie akcelerometru może powodować błędy w zachowaniu się procesji -- mianowicie mogłoby sprawić, że kierunek poruszania się procesji zostanie ustalony i niezależnie od wykonywanych przez gracza manewrów gra nieprzerwanie próbować będzie odczytać wskazania akcelerometra i poruszać procesją zgodnie z tymi odczytami.
	\subsubsection{Rozpoznanie}
	Przy uruchomieniu zakładamy, że płytka jest ustawiona w pozycji horyzontalnej na płaskiej powierzchni i oddziałuje na nią wektor przyspieszenia grawitacyjnego $1g$ skierowany pionowo w dół, tj. o współrzędnych $(0,0,-1)$. Następnie obliczany jest kwadrat długości obecnie odczytanego przez akcelerometr wektora przyspiesznia. Jeżeli wartość normy odczytanego wektora przyspieszenia $X$ przy przyjmowanym zakresie akcelerometru (wynoszącym $2g$) mieści się w przedziale
	$$0.78125\;g =\sqrt{ \frac{2500}{4096} }\; g \; < \| X \| \; < \; \sqrt{ \frac{6000}{4096} }\; g \simeq 1.210307\; g ,$$
	odczyty uznajemy za poprawne. W przypadku wystąpienia odczytu wykraczającego poza ten zakres, program uznaje akcelerometr za uszkodzony.
	%Na akcelerometrze 64 = 1g 
	\subsubsection{Reakcja}
	Zmienna opisująca poprawność działania akcelerometru zostaje ustawiona na wartość $BROKEN = 0$. W wyniku tego kolejne wykonania głównej pętli programu nie uwzględniają już odczytywania wartości wskazywanych przez akcelerometr. Wprawdzie uniemożliwia to dalsze sterowanie przy pomocy akcelerometru (przynajmniej do czasu ponownego uruchomienia urządzenia), aczkolwiek nadal możliwe jest granie w Procesję przy pomocy joysticka.
	\subsection{Uszkodzenie joysticka}
	Uszkodzenie manipulatora drążkowego może spowodować odczytywanie wskazań, które nie zmieniają się lub zmieniają się w sposób całkowicie losowy. W naszej analizie skupiliśmy się na pierwszym przypadku, który uznaliśmy za dużo bardziej prawdopodobny. Wystąpienie takiej awarii sprawiłoby, że procesja (niezależnie od życzenia użytkownika i sterowania akcelerometrem) poruszałaby się w jednym kierunku, skutecznie uniemożliwiając zabawę.
	\subsubsection{Rozpoznanie}
	W zmiennej \textit{prev\_state} przechowywany jest poprzedni odczyt z joysticka. 
	Jeżeli wskazania nie zmieniają się przez ustalony czas (odpowiadający stu wykonaniom pętli), uznajemy, że nastąpiła awaria. Wyjątek od tej reguły stanowi sytuacja, gdy wskazywane jest położenie joysticka w pozycji $0$ (nienaciśniętej). 
	\subsubsection{Reakcja}
	Gdy rozpoznana zostaje awaria urządzenia peryferyjnego manipulatora drążkowego następuje zaprzestanie odczytywania wskazań tegoż manipulatora. Wznowienie odczytu nie następuje -- aby grać dalej należy korzystać z akcelerometra. W przypadku gdy chcemy korzystać z joysticka należy zrestartować urządzenie.
	
	\subsection{Uszkodzenie wyświetlacza 7segmentowego}
	Uszkodzenie wyświetlacza siedmiosegmentowego ma jedynie znaczenie kosmetyczne i nie wpływa w żaden sposób na działanie całości programu. W związku z tym nie zużywamy mocy obliczeniowej na sprawdzanie poprawności jego działania ani nie reagujemy na jego ewentualne uszkodzenie.
	
	\subsection{Uszkodzenie pokrętła ADC}
	Uszkodzenie pokrętła nie ma dużego wpływu na rozgrywkę -- sprawia jedynie, że prędkość (a zatem poziom trudności) gry zostaje ustalona i użytkownik nie będzie miał możliwości jej modyfikacji. W przypadku ustalenia zbyt dużej prędkości gra może stać się zbyt trudna, by być satysfakcjonująca.
	
	Niestety, nie zostały uwzględnione metody autodiagnostyki dla tego rodzaju awarii.
\section{Wykorzystane noty katalogowe, dokumentacja i literatura}
		
		\bibliographystyle{plain}
\begin{thebibliography}{abcd}
\bibitem{INST}{
	\textit{UM10375 LPC1311/13/42/43 User manual},
	{21 June 2012},
	\textbf{Rev. 5},
}		
\bibitem{ADCINST}{
\textit{Understanding SAR ADCs: Their Architecture and Comparison with Other ADCs},
	{02 October 2001},
	\textbf{Maxim Integrated Products, Inc.}	
}
\bibitem{ADCtut}
\textit{LPC1343 ADC programming tutorial},
	{18 November 2017},
	\textbf{Umang Gajera}

\bibitem{PCA}{
	\textit{PCA9532, 16-bit I2C-bus LED dimmer},
	{22 August 2016}, 
	\textbf{Rev. 4.1, Product data sheet}
}

\bibitem{LUX}{
\textit{ISL29003 Data Sheet FN7464.6},
{17 November 2011},
\textbf{Intersil, Mouser Electronics}
}

\bibitem{ACCEL}{
	\textit{$\pm$2g/$\pm$4g/$\pm$8g Three Axis Low-g Digital Output Accelerometer},
	{12/2009},
	\textbf{Document Number: MMA7455L
	Rev 10} 
	}
	
\end{thebibliography}

\end{document}



		%Charakteryzacja metryczności przez kulę otwartą.
